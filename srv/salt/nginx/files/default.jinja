server {
        # Alternativ auf {{ salt['network.interface_ip']('eth0') }} binden, wobei darüber keine IPv6
        # verfügbar ist. Siehe https://docs.saltproject.io/en/latest/ref/modules/all/salt.modules.network.html#salt.modules.network.interface_ip
        listen 80 default_server;
        listen [::]:80 default_server;

        # SSL configuration
        # listen 443 ssl default_server;
        # listen [::]:443 ssl default_server;

        # Self signed certs generated by the ssl-cert package
        # Don't use them in a production server!
        # include snippets/snakeoil.conf;

        {% if 'php' in grains['role'] %}
        root /var/www/app;
        {% else %}
        root /var/www/html;
        {% endif %}

        # Add index.php to the list if you are using PHP
        index index.html index.htm index.nginx-debian.html {% if 'php' in grains['role'] %}index.php{% endif %};

        server_name _;

        {% if 'php' in grains['role'] %}
        # Nach https://symfony.com/doc/current/setup/web_server_configuration.html#nginx
        # Ja, es ist eigentlich falsch, das an die "PHP" Role zu koppeln, und nicht an
        # eine App Role oder mehr noch, aber ich war hier einfach bequem.

        location / {
                # try to serve file directly, fallback to index.php
                try_files $uri /index.php$is_args$args;
        }


        location ~ ^/index\.php(/|$) {
                include snippets/fastcgi-php.conf;
        
                fastcgi_pass unix:/run/php/php8.2-fpm.sock;
                fastcgi_split_path_info ^(.+\.php)(/.*)$;
                include fastcgi_params;

                # When you are using symlinks to link the document root to the
                # current version of your application, you should pass the real
                # application path instead of the path to the symlink to PHP
                # FPM.
                # Otherwise, PHP's OPcache may not properly detect changes to
                # your PHP files (see https://github.com/zendtech/ZendOptimizerPlus/issues/126
                # for more information).
                # Caveat: When PHP-FPM is hosted on a different machine from nginx
                #         $realpath_root may not resolve as you expect! In this case try using
                #         $document_root instead.
                fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
                fastcgi_param DOCUMENT_ROOT $realpath_root;
                # Prevents URIs that include the front controller. This will 404:
                # http://domain.tld/index.php/some-path
                # Remove the internal directive to allow URIs like this
                # internal;
        }

        # return 404 for all other php files not matching the front controller
        # this prevents access to other php files you don't want to be accessible.
        location ~ \.php$ {
                return 404;
        }
        {% else %}
        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ =404;
        }
        {% endif %}

}
